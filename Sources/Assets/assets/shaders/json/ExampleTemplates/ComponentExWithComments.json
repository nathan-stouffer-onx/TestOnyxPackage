{
    "MainComment1": "This is an example Shader Component file. This will be where you define (almost) all your shader code.",
    "MainComment2": "Every comment object property will be ignored in the shader processor",

    "sortOrderComment": "This states in which order the component will be placed when put into a shader signature",
    "sortOrder": 0,

    "requirementsComment1": "This states the required bool and int options the full shader will need if this component is included",
    "requirementsComment2": "Setting a boolean option as false here will not force it to be false if it was set as true",
    "requirementsComment3": "All requirement options are listed here",
    "requirements":
    {
        "position": true,
        "transformPosition": true,
        "positionOutput": true,
        "normal": true,
        "tangent": true,
        "uv0": true,
        "color0": true,
        "addUV": 1,
        "addColor": 1
    },

    "boolsComment1": "This states all the possible boolean options the component has.",
    "boolsComment2": "IMPORTANT: Note that the booleans in the signature DO NOT match the ordering in the json file.",
    "boolsComment3": "The signature booleans are in alphanumeric ASCII ordering from least to greatest.",
    "boolsComment4": "My suggestion is to list your bools in the same ordering to prevent confusion and headache.",
    "bools":
    {
        "exampleBool1": true,
        "exampleBool2": false
    },

    "intsComment1": "This states all possible int options the component has.",
    "intsComment2": "IMPORTANT: Like the bools object, the ints in the signature are in alphanumeric ASCII ordering as well",
    "intsComment3": "I suggest you list your int names in the same ordering as well",
    "ints": {
        "ColorCount": 0,
        "UVCount": 1
    },

    "inputsComment": "This states what vertex inputs (attributes) the shader will use",
    "inputs":
    [
        {
            "aliasComment1": "Alias is effectively the input's name. The alias will take the value from the assigned attribute name",
            "aliasComment2": "and can be treated as the actual name itself when writing your shader code.",
            "aliasComment3": "To see how the alias name and data type is used to select the real name, see ShaderDefinition.cpp's",
            "aliasComment4": "intrinsicMap and addDataSource function.",
            "alias": "inputName", 

            "dataTypeComment1": "Data type of the input. Each data type maps to a list of assignable attribute names",
            "dataTypeComment2": "See ShaderDefiniition.cpp's sInputIntrinsics and sInputIntrinsicsInstanced for the full list",
            "dataType": "vec4",

            "conditionalComment1": "Will add the input to the shader if the given bool/int condition passes.",
            "conditionalComment2":  "Doesn't support multiple of the same property names/conditional lists (yet)",
            "conditional": {
                "ifBoolTrue": "exampleBool1",
                "ifBoolFalse": "exampleBool2",
                "ifIntEqual": "UVCount",
                "targetValue": 1,
                "forThisIntTimes": "I don't know what this does",
                "loopReplaceValue": "I don't know what this does"
            }

        }
    ],

    "outputsComment": "This states what vertex outputs (varyings) the shader will use. Largely the same functionality as inputs",
    "outputs":
    [
        {
            "aliasComment1": "Alias is effectively the output's name. The alias will take the value from the assigned attribute name",
            "aliasComment2": "and can be treated as the actual name itself when writing your shader code.",
            "aliasComment3": "To see how the alias name and data type is used to select the real name, see ShaderDefinition.cpp's",
            "aliasComment4": " sOutputIntrinsics and addDataSource function.",
            "alias": "outputName", 

            "dataTypeComment1": "Data type of the output. Each data type maps to a list of assignable attribute names",
            "dataTypeComment2": "See ShaderDefiniition.cpp's sOutputIntrinsics and sInstancedIntrinsics for the full list",
            "dataType": "vec4",

            "conditionalComment1": "Will add the output to the shader if the given bool/int condition passes.",
            "conditionalComment2":  "Doesn't support multiple of the same property names/conditional lists (yet)",
            "conditional": {
                "ifBoolTrue": "exampleBool1",
                "ifBoolFalse": "exampleBool2",
                "ifIntEqual": "UVCount",
                "targetValue": 1,
                "forThisIntTimes": "I don't know what this does",
                "loopReplaceValue": "I don't know what this does"
            }
        }
    ],

    "chunksComment": "This is where your shader code will go. Lines of shader code are divided into chunks",
    "chunks": [
        {
            "linesComment": "Each line of code will be stored as an array of json strings",
            "lines": [
                "#include <common.sh>",
                "#include \"OnyxFunctions.sc\""
            ],

            "positionComment": "Which section the code will go. See ShaderEnums.h's ShaderInsertPositions for the full list of positions",
            "position": "Includes",

            "positionOffsetComment": "Number of lines offset from the given position.",
            "positionOffset": 0,
            
            "typeComment": "The type of shader to include the code at. See ShaderEnums.h's ShaderType for the full list of types",
            "type": "Vertex_and_Pixel",

            "conditional": {
                "ifBoolTrue": "exampleRequiredBool"
            }
        },
        {
            "dataComment": "If you only need one line of code, the data property will be faster",
            "data": "#include \"OnyxFragFunctions.sc\"",

            "position": "Includes",
            "type": "Pixel"
        }
    ],

    "shaderParametersComment": "This is where we define our shader parameters, including uniform variables",
    "shaderParameters": [
        {
            "componentNameComment": "Not sure why this is needed. Maybe if the realtimeUniform is set to false, this will be used as a signature name? I don't think this is necesary",
            "componentName": "BaseShader",

            "imguiProperitezsComment": "Properties for use when changing the uniform variables through DebugUI in real time",
            "imguiRate": 0.01,
            "max": -1.0,
            "min": -1.0,

            "nameComment": "name of the parameter",
            "name": "u_tileMin",

            "realtimeUniformComment1": "Boolean stating if the parameter is a real time uniform. I don't think this property is necessary.",
            "realtimeUniformComment2": "The only non realtime uniform params are up in bools and ints json objects",
            "realtimeUniform": true,

            "instancedComment1": "Boolean that treats the paramater as an instance variable.",
            "instancedComment2": "Note that it will take the TEXCOORD7-0 names in descending order.",
            "instancedComment3": "Note that application-side, the instanced data is order from i_data0-5, whereas on the json component side, the instanced inputs are ordered in reverse",
            "instanced": false,

            "typeComment1": "type of the parameter as well as its default val. BGFX only supports vec4's, mat3's, and mat4's.",
            "typeComment2": "Therefore, whenever referring to these uniforms in your shader code, make sure to convert/swizzle it to",
            "typeComment3": "your desired datatype. texture and color are also valid datatypes here",
            "type": "vec3",
            "vec3": {
                "x": -10000.0,
                "y": -10000.0,
                "z": 0.0
            },
            "conditionalComment": "Removes uniform variable if boolean condition is not true",
            "conditional": {
              "ifBoolTrue": "exampleBool1"
            },

          "anisoFilterComment": "Sets anisotropic minification/magnification filtering. If false, then defaults to point sampling",
          "anisoFilter": true,

          "samplerFlagsComment": "Uint that sets bgfx texture sampling flags. Below sets the min/mag filters to point sampling"
          "samplerFlags": 320
        }
    ]




}